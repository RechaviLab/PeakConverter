from collections import deque
from signal import signal, SIGPIPE, SIG_DFL
import subprocess
import tempfile
import sys
import pandas as pd

"""
This program receives the RefSeq UCSC table file and a cufflinks isoform FPKM
file as input and outputs a bed file with transcriptomic coordinates, a bed file
with genomic coordinates limited to exons and an excel file for metagene analysis.
"""


class Transcript:
    def __init__(self, tx_id, chrom, strand, tx_start, tx_end, cds_start,
                 cds_end, exon_starts, exon_ends, gene_id):
        self.id = tx_id
        self.chrom = chrom
        self.strand = strand
        self.txs = tx_start
        self.txe = tx_end
        self.cdss = cds_start
        self.cdse = cds_end
        self.genomic_starts = exon_starts
        self.genomic_ends = exon_ends
        self.gid = gene_id
        self.trans_starts = deque()
        self.trans_ends = deque()
        self.type = None
        self.ctis = None
        self.stop = None
        self.get_transcriptomic_coordinates()
        self.get_start_stop()

    def __len__(self):
        return sorted(self.trans_ends, reverse=True)[0]

    def get_transcriptomic_coordinates(self):
        """
        This class function calculates the transcriptomic coordinates of each exon
        in the transcript from their genomic coordinates.
        """
        if self.strand == "+":
            b = 0
            for index, exon_st in enumerate(self.genomic_starts):
                exon_end = self.genomic_ends[index]
                tr_exon_st = b
                tr_exon_end = b + exon_end - exon_st
                self.trans_starts.append(tr_exon_st)
                self.trans_ends.append(tr_exon_end)
                b = b + exon_end - exon_st
        elif self.strand == "-":
            b = 0
            for index, exon_st in enumerate(reversed(self.genomic_starts)):
                exon_end = list(reversed(self.genomic_ends))[index]
                tr_exon_st = b
                tr_exon_end = b + exon_end - exon_st
                self.trans_starts.appendleft(tr_exon_st)
                self.trans_ends.appendleft(tr_exon_end)
                b = b + exon_end - exon_st

    def get_start_stop(self):
        """
        This class function calculates the transcriptomic coordinates of the canonical
        start codon and the stop codon. It returns -1 for both if it is a non-coding
        transcript.
        """
        if self.cdss == self.cdse:
            self.ctis = -1
            self.stop = -1
            self.type = "non-coding"
        else:
            self.type = "coding"
            for exon_start, exon_end, tr_exon_start in zip(self.genomic_starts, self.genomic_ends,
                                                           self.trans_starts):
                if exon_start <= self.cdss <= exon_end:
                    if self.strand == "+":
                        self.ctis = tr_exon_start + self.cdss - exon_start
                    else:
                        self.stop = tr_exon_start + exon_end - self.cdss
                if exon_start <= self.cdse <= exon_end:
                    if self.strand == "+":
                        self.stop = tr_exon_start + self.cdse - exon_start
                    else:
                        self.ctis = tr_exon_start + exon_end - self.cdse


def build_transcript(array_line):
    """
    This function takes a line from the table array (which is a list) and uses
    the class Transcript to build a transcript from that line. It outputs the
    transcript object.
    """
    tx_id = array_line[1]
    chrom = array_line[2]
    strand = array_line[3]
    txStart = array_line[4]
    txEnd = array_line[5]
    cdsStart = array_line[6]
    cdsEnd = array_line[7]
    exonStarts_list = array_line[8]
    exonEnds_list = array_line[9]
    gene_id = array_line[10]
    return Transcript(tx_id, chrom, strand, txStart, txEnd, cdsStart,
                      cdsEnd, exonStarts_list, exonEnds_list, gene_id)


def build_transcriptome(table_array, key='uid'):
    """
    This function takes a table array generated by read_table_into_array and a key
    and returns a dictionary in which the values are objects of the class Transcript.
    """
    transcripts = {}
    keydict = {'uid': 0, 'gid': 10, 'txid': 1}
    if key not in ['gid', 'txid', 'uid']:
        print('Invalid key type for transcripts dictionary! Aborting.')
        sys.exit(0)
    else:
        for line in table_array:
            if line[keydict[key]] not in transcripts:
                transcripts[line[keydict[key]]] = [build_transcript(line)]
            else:
                transcripts[line[keydict[key]]].append(build_transcript(line))
    return transcripts


def get_parameters(tx_dict):
    parameters = []
    parameter_list = ['Tx_ID', 'ATG', 'Stop', 'Length', 'FirstSpliceSite', 'LastSpliceSite']
    for tx_class in tx_dict:
        for tx in tx_dict[tx_class]:
            starts = sorted(tx.trans_starts)
            if len(starts) > 1 and tx.ctis > 0:
                par = {'Tx_ID': tx.id,
                       'ATG': tx.ctis,
                       'Stop': tx.stop,
                       'Length': len(tx),
                       'FirstSpliceSite': starts[1],
                       'LastSpliceSite': starts[-1]}
            elif len(starts) > 1:
                par = {'Tx_ID': tx.id,
                       'ATG': '-1',
                       'Stop': '-1',
                       'Length': len(tx),
                       'FirstSpliceSite': starts[1],
                       'LastSpliceSite': starts[-1]}
            elif tx.ctis > 0:
                par = {'Tx_ID': tx.id,
                       'ATG': tx.ctis,
                       'Stop': tx.stop,
                       'Length': len(tx),
                       'FirstSpliceSite': '-1',
                       'LastSpliceSite': '-1'}
            else:
                par = {'Tx_ID': tx.id,
                       'ATG': '-1',
                       'Stop': '-1',
                       'Length': len(tx),
                       'FirstSpliceSite': '-1',
                       'LastSpliceSite': '-1'}
            parameters.append([par[parm] for parm in parameter_list])
    parameters_df = pd.DataFrame(parameters)
    parameters_df.columns = [parm for parm in parameter_list]
    return parameters_df


def gen2tr(bedfile, tx_dict):
    """
    This function takes a genomic bed file and a dictionary of transcripts (of class Transcript),
    intersects the bed file with the transcripts using bedtools intersect and outputs the
    transcriptomic coordinates of the bed features into a file name of choice
    """
    with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_bed_key:
        for tx_class in tx_dict:
            for tx in tx_dict[tx_class]:
                for exon_start, exon_end, tr_exon_st, tr_exon_end in \
                    zip(tx.genomic_starts, tx.genomic_ends,
                        tx.trans_starts, tx.trans_ends):
                    print(tx.chrom, exon_start, exon_end, "*", "*",
                          tx.strand, tx.id, tr_exon_st, tr_exon_end,
                          sep="\t", file=temp_bed_key)
        temp_bed_key.seek(0)
        intersection = subprocess.Popen(['bedtools', 'intersect', '-a',
                                         bedfile, '-b', temp_bed_key.name,
                                         '-wo'], stdout=subprocess.PIPE)
        exon_limited_peaks = subprocess.Popen(['bedtools', 'intersect', '-a',
                                               bedfile, '-b', temp_bed_key.name,
                                               '-f', '0.5'], stdout=subprocess.PIPE)
        sorted_elp = subprocess.Popen(['bedtools', 'sort', '-i'],
                                      stdin=exon_limited_peaks.stdout,
                                      stdout=subprocess.PIPE)
        merged_elp = subprocess.Popen(['bedtools', 'merge', '-nms', '-i'],
                                      stdin=sorted_elp.stdout,
                                      stdout=subprocess.PIPE)
        with open(args.output+'_exonpeaks.bed', 'w') as exon_peak_output:
            for l in merged_elp.stdout:
                print(l.decode().strip(), file=exon_peak_output)
    with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp_tr_bed:
        for line in intersection.stdout:
            myline = line.decode().strip().split()
            p_start = int(myline[1])
            p_end = int(myline[2])
            peak_id = myline[3]
            ex_st = int(myline[-9])
            ex_end = int(myline[-8])
            strand = myline[-5]
            tx_id = myline[-4]
            tr_exon_start = int(myline[-3])
            overlap = int(myline[-1])
            if strand == "+":
                if p_start <= ex_st:
                    print(tx_id, tr_exon_start, tr_exon_start+overlap, peak_id,
                          sep="\t", file=temp_tr_bed)
                elif p_start > ex_st:
                    gap = p_start - ex_st
                    print(tx_id, tr_exon_start+gap, tr_exon_start+gap+overlap, peak_id,
                          sep="\t", file=temp_tr_bed)
            elif strand == "-":
                if p_end >= ex_end:
                    print(tx_id, tr_exon_start, tr_exon_start+overlap, peak_id,
                          sep="\t", file=temp_tr_bed)
                elif p_end < ex_end:
                    gap = ex_end - p_end
                    print(tx_id, tr_exon_start+gap, tr_exon_start+gap+overlap, peak_id,
                          sep="\t", file=temp_tr_bed)
        temp_tr_bed.seek(0)
        sorted_bed = subprocess.Popen(['bedtools', 'sort', '-i', temp_tr_bed.name],
                                      stdout=subprocess.PIPE)
        merged_bed = subprocess.Popen(['bedtools', 'merge', '-nms', '-d', '10', '-i'],
                                      stdin=sorted_bed.stdout, stdout=subprocess.PIPE)
        trdf = pd.read_csv(merged_bed.stdout, header=None, sep='\t')
        trdf.columns = ['Tx_ID', 'Peak_Start', 'Peak_End', 'Peak_Names']
        return trdf


def get_user_arguments():
    """
    This function parses the user supplied arguments using argparse.
    It returns a parser.parse_args object.
    """
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--bed-file', action='store', dest='bedfile',
                        help='Path to MACS2 Peaks file (Or other BED format peak file)')
    parser.add_argument('--table-file', action='store', dest='tablefile',
                        help='Path to RefSeq UCSC Table file')
    parser.add_argument('--output-prefix', action='store', dest='output',
                        help='Prefix of output files')
    parser.add_argument('--expression-file', action='store', dest='expfile',
                        help='Path to cufflinks output isoforms.fpkm_tracking file')
    return parser.parse_args()


def read_table_into_array(table_file, selected_transcripts=None):
    """
    This function takes a table file and a set of transcripts and
    loads the selected transcripts into an array (list of lists). If no list of transcripts
    is supplied then it loads all transcripts into the array.
    The array has the following columns:
    ID|Tx ID|Chrom|Strand|Tx Start|Tx End|CDS Start|CDS End|Exon Starts (List)|Exon Ends (List)|Gene ID
    """
    with open(table_file, 'r') as opened_table_file:
        first_line = opened_table_file.readline().strip().split()
        id_counter = 1
        table_array = []
        if selected_transcripts:
            if "bin" in first_line[0]:
                for line in opened_table_file:
                    split_line = line.strip().split('\t')[1:]
                    if split_line[0] in selected_transcripts:
                        integer_values = [int(split_line[a]) for a in range(3, 7)]
                        exon_starts = [int(a) for a in split_line[8].split(',')[:-1]]
                        exon_ends = [int(a) for a in split_line[9].split(',')[:-1]]
                        table_array.append([id_counter] + split_line[:3] + integer_values +
                                           [exon_starts] + [exon_ends] + [split_line[11]])
                        id_counter += 1
            else:
                for line in opened_table_file:
                    split_line = line.strip().split('\t')
                    if split_line[0] in selected_transcripts:
                        integer_values = [int(split_line[a]) for a in range(3, 7)]
                        exon_starts = [int(a) for a in split_line[8].split(',')[:-1]]
                        exon_ends = [int(a) for a in split_line[9].split(',')[:-1]]
                        table_array.append([id_counter] + split_line[:3] + integer_values +
                                           [exon_starts] + [exon_ends])
                        id_counter += 1
        else:
            if "bin" in first_line[0]:
                for line in opened_table_file:
                    split_line = line.strip().split('\t')[1:]
                    integer_values = [int(split_line[a]) for a in range(3, 7)]
                    exon_starts = [int(a) for a in split_line[8].split(',')[:-1]]
                    exon_ends = [int(a) for a in split_line[9].split(',')[:-1]]
                    table_array.append([id_counter] + split_line[:3] + integer_values +
                                       [exon_starts] + [exon_ends] + [split_line[11]])
                    id_counter += 1
            else:
                for line in opened_table_file:
                    split_line = line.strip().split('\t')
                    integer_values = [int(split_line[a]) for a in range(3, 7)]
                    exon_starts = [int(a) for a in split_line[8].split(',')[:-1]]
                    exon_ends = [int(a) for a in split_line[9].split(',')[:-1]]
                    table_array.append([id_counter] + split_line[:3] + integer_values +
                                       [exon_starts] + [exon_ends])
                    id_counter += 1
    return table_array


def isoform_gene_dict(table_file):
    """
    This function receives a table file and returns a dictionary in which
    the keys are isoforms and the values are genes, for use in the
    choose_selected_cufflinks function.
    """
    with open(table_file, 'r') as opened_table_file:
        first_line = opened_table_file.readline().strip().split()
        gene_dict = {}
        if "bin" in first_line[0]:
            for line in opened_table_file:
                split_line = line.strip().split('\t')[1:]
                gene_dict[split_line[0]] = split_line[11]
    return gene_dict


def choose_selected_cufflinks(input_file, table_file):
    """
    This function receives a cufflinks output file isoforms.fpkm_tracking
    and a UCSC table file.
    It chooses the isoforms that will be used for genomic to transcriptomic
    conversion in the following order:
    1. Most expressed isoform of a gene by FPKM
    2. Longest coding isoform.
    3. Longest isoform.
    It returns a set of the chosen isoforms.
    """
    iso_dict = {}
    ret_list = []
    gene_dict = isoform_gene_dict(table_file)
    with open(input_file, 'r') as input_f:
        _ = input_f.readline()
        for line in input_f:
            fline = line.strip().split()
            isoform = fline[3]
            fpkm = float(fline[9])
            txlength = int(fline[7])
            if isoform in gene_dict:
                gene = gene_dict[isoform]
                if gene in iso_dict:
                    if fpkm > iso_dict[gene][1]:
                        iso_dict[gene] = (isoform, fpkm, txlength)
                    elif fpkm == iso_dict[gene][1] and isoform[:2] == "NM" \
                            and iso_dict[gene][0][:2] == "NR":
                        iso_dict[gene] = (isoform, fpkm, txlength)
                    elif fpkm == iso_dict[gene][1] and txlength > iso_dict[gene][2]:
                        iso_dict[gene] = (isoform, fpkm, txlength)
                else:
                    iso_dict[gene] = (isoform, fpkm, txlength)
    for gene in iso_dict:
        ret_list.append(iso_dict[gene][0])
    return set(ret_list)


def check_dependencies():
    """
    This function checks that the dependencies are defined in the system's PATH.
    If not, it terminates the script.
    """
    import shutil
    if not shutil.which("bedtools"):
        print("BEDtools not installed or not defined in PATH!")
        sys.exit(0)
    return


args = get_user_arguments()
signal(SIGPIPE, SIG_DFL)
check_dependencies()
chosen = choose_selected_cufflinks(args.expfile, args.tablefile)
tb_array = read_table_into_array(args.tablefile, chosen)
tx_dict = build_transcriptome(tb_array, 'gid')
parameters_df = get_parameters(tx_dict)
result = gen2tr(args.bedfile, tx_dict)
with open(args.output+'_tx.bed', 'w') as transcriptomic_output:
    for _, row in result.iterrows():
        tx = row[0]
        tr_start = row[1]
        tr_end = row[2]
        peak_names = row[3]
        print(tx, tr_start, tr_end, peak_names, sep='\t', file=transcriptomic_output)
result['Peak_Middle'] = ((result.pop('Peak_Start')+result.pop('Peak_End'))/2).round()
merged = pd.merge(result, parameters_df, on='Tx_ID')
writer = pd.ExcelWriter(args.output+'_excel.xlsx', engine='xlsxwriter')
merged.to_excel(writer, sheet_name='Metagene_Table', index=False)
writer.save()
